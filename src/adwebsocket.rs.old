// use tungstenite::connect;
// use tungstenite::protocol::Message;
// use serde_json::json;
// use std::time::Duration;

// fn main() {
//     let url = "ws://127.0.0.1:9222/devtools/page/3F04ACEDBAFC9BFC4BE354CE53A43B59".to_string();
    
//     // Connettersi al WebSocket del Chrome DevTools Protocol
//     let (mut socket, _) = connect(url)
//         .expect("Errore di connessione");

//     // Abilita il dominio Network per monitorare la rete
//     let enable_network_cmd = json!({
//         "id": 1,
//         "method": "Network.enable"
//     });
//     socket.send(Message::Text(enable_network_cmd.to_string().into())).unwrap();

//     // Imposta un nuovo User-Agent
//     let user_agent_cmd = json!({
//         "id": 2,
//         "method": "Network.setUserAgentOverride",
//         "params": {
//             "userAgent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
//         }
//     });
//     socket.send(Message::Text(user_agent_cmd.to_string().into())).unwrap();

//     // Disabilita i Web Workers
//     // let disable_workers = json!({
//     //     "id": 1,
//     //     "method": "Emulation.setScriptExecutionDisabled",
//     //     "params": { "value": true }
//     // });

//     // socket.send(tungstenite::Message::Text(disable_workers.to_string().into()))
//     //     .expect("Errore nell'invio del comando");

//     // Imposta un nuovo User-Agent per JavaScript (navigator.userAgent)
//     // let js_user_agent_cmd = json!({
//     //     "id": 3,
//     //     "method": "Runtime.evaluate",
//     //     "params": {
//     //         "expression": r#"
//     //             Object.defineProperty(navigator, 'userAgent', {
//     //                 get: function() { 
//     //                     return 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'; 
//     //                 }
//     //             });
    
//     //             class FakeWorker extends Worker {
//     //                 constructor(scriptURL, options) {
//     //                     super(scriptURL, options);
                        
//     //                     this.addEventListener('message', (event) => {
//     //                         if (event.data === 'getUserAgent') {
//     //                             this.postMessage({
//     //                                 type: 'userAgent',
//     //                                 data: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
//     //                             });
//     //                         }
//     //                     });
//     //                 }
//     //             }
    
//     //             window.Worker = FakeWorker;
//     //         "#
//     //     }
//     // });
//     // socket.send(Message::Text(js_user_agent_cmd.to_string().into())).unwrap();

//     // Comando per navigare a una pagina
//     let navigate_cmd = json!({
//         "id": 5,
//         "method": "Page.navigate",
//         "params": {
//             "url": "https://gitlab.com/users/sign_in"
//         }
//     });
//     socket.send(Message::Text(navigate_cmd.to_string().into())).unwrap();
//     socket.close(None).expect("Errore nella chiusura della connessione WebSocket");

//     // Continuare a leggere i messaggi di risposta dal WebSocket
//     loop {
//         let msg = socket.read().unwrap();
        
//         match msg {
//             Message::Text(text) => {
//                 // Stampa i messaggi di risposta (JSON)
//                 println!("Risposta ricevuta: {}", text);

//                 // Se trovi un messaggio che indica la fine del caricamento della pagina
//                 if text.contains(r#""method":"Page.loadEventFired""#) {
//                     println!("Pagina caricata.");
//                     break;
//                 }
//             },
//             Message::Close(_) => {
//                 println!("Connessione chiusa.");
//                 break;
//             },
//             _ => {}
//         }

//         // Puoi aggiungere un timeout per evitare un loop infinito in caso di problemi
//         std::thread::sleep(Duration::from_secs(1));
//     }
// }